{%extends "base.html" %}
{%block content%}

<h1>
    <img src="{{ url_for('static', filename='documentation_button.png') }}" height="100px">
    Project documentation
</h1>

<p>
    In this page we will go thorugh 
    <a href="#software_analysis">software analysis</a>
    and 
    <a href="#software_design">software design</a>.
</p>

<a id="software_analysis">
    <h2> Software analysis </h2>
</a>

<p>
    the sfotware analysis is based on the 
    <a href='https://github.com/kcajj/human_genome_webapp/blob/GFF3-subclass/MarkdownFiles/Project_specification.md' target="_blank">
    project specification</a>.
    <br>
    We built some CRC cards that give an idea of the role of each class.
</p>
<p>
    We identified 4 classes to build:
</p>

<h4> DatasetReader </h4>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>DatasetReader
        </th>
        <th>
            <b>Supeclass:</b><br>None
        </th>
        <th>
            <b>Subclasses:</b><br>GFF3DatasetReader
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>Provide an abstract interface for <br>the subclass</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>None</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    <br>
    The DatasetReader class should be an abstract class, it should provide the abstract methods that 
    will be implemented in the subclass.
</p>

<h4> GFF3DatasetReader </h4>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>GFF3DatasetReader
        </th>
        <th>
            <b>Supeclass:</b><br>DatasetReader
        </th>
        <th>
            <b>Subclasses:</b><br>None
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>Reads specifically a GFF3 file</li>
                <li>Return a dataset object</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>Dataset</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    <br>
    The GFF3DatasetReader class should be specific for GFF3 files, it should check if the input file is a 
    .gff3 file and then read it correctly, returning a pandas Dataframe inside a Dataset object.
</p>

<h4> Dataset </h4>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>Dataset
        </th>
        <th>
            <b>Supeclass:</b><br>None
        </th>
        <th>
            <b>Subclasses:</b><br>GFF3Dataset
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>non-specific class to store data</li>
                <li>create a GFF3 dataset object if <br>the input data is GFF3</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>pandas.DataFrame</li>
                <li>GFF3Dataset</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    <br>
    The Dataset class should have two main functions:
    <ul>
        <li>It is a class that wraps a generic pandas dataframes 
            and allows the other parts of the software to access it;
        </li>
        <li>
            It checks if the dataframe that it is wrapping is a gff3 dataset and, if so, it 
            wraps it in another class, specific for gff3 files.
        </li>
    </ul>
</p>

<h4> GFF3Dataset </h4>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>GFF3Dataset
        </th>
        <th>
            <b>Supeclass:</b><br>Dataset
        </th>
        <th>
            <b>Subclasses:</b><br>None
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>Be specific for GFF3 datasets</li>
                <li>Perform all of the active operations</li>
                <li>Handle the activation of the operations</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>pandas.DataFrame</li>
                <li>pandas.Series</li>
                <li>Dataset</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    <br>
    The GFF3Dataset class should be specific for GFF3 files, it just wraps a pandas dataframe and 
    provides several operations that retrieve some characteristics of the dataframe or that 
    filter the dataframe on the basis of a condition.
</p>
<p>
    The operations are:
    <ul>
        <li>General information</li>
        <li>Unique sequence IDs:</li>
        <li>Unique types of features</li>
        <li>Features with the same source</li>
        <li>Entries for each type of feature</li>
        <li>Data of entire chromosomes</li>
        <li>Fraction of unassembled sequences</li>
        <li>Features with source ensembl, havana, and ensembl_havana</li>
        <li>Entries for each type of feature, on the database with ensembl, havana and ensembl_havana sources</li>
        <li>All gene names</li>
    </ul>
</p>
<p>
    This class should also automatically handle the activation of the operations. The activation
    should be performed through a decorator.<br>
    For each GFF3Dataset object that is created in the program, a customised list of active operations 
    is created; in this way, even on filtered dataset, we will be able to perform some active operation,
    meaningful for the specifc dataset under consideration.
</p>

<a id="software_design">
    <h2> Software design </h2>
</a>

<p>
    Now we will present a detailed view over the software. This UML diagram shows all of the components of 
    each class and the interactions between the classes.<br>
    Click on a class to explore the detailed documentation.
</p>

<div class="UML">
    <img src="{{ url_for('static', filename='UML_image.png') }}" width="100%">
    <a href="#DatasetReader"><button class="DatasetReader"></button></a>
    <a href="#GFF3DatasetReader"><button class="GFF3DatasetReader"></button></a>
    <a href="#Dataset"><button class="Dataset"></button></a>
    <a href="#GFF3Dataset"><button class="GFF3Dataset"></button></a>
    <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html" target="_blank"><button class="pandas_DataFrame"></button></a>
    <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html" target="_blank"><button class="pandas_Series"></button></a>
</div>

<p>
    <br>
    The software is organised into 4 python modules:
    <a href="#dataset_reader">dataset_reader</a>, 
    <a href="#dataset">dataset</a>, 
    <a href="#functions">functions</a>, 
    <a href="#main">main</a>.
</p>

<a id="dataset_reader">
    <h2><b>dataset_reader</b></h2>
</a>
<p>
    The dataset_reader module performs the decodification of the GFF3 file, it contains a specific class that is able 
    to read a .gff3 file and that returns a Dataset object.
</p>
<p>
    The module requires:
    <ul>
        <li>abc library: it is used to define the Dataset reader class, which is an abstract class</li>
        <li>pandas library: the reading operation is performed thorugh pandas.read_csv(), 
            the resulting pandas DataFrame is wrapped in a Dataset object
        </li>
        <li>Dataset module</li>
    </ul>
</p>
<p>
    this module contains two classes:
</p>
<a id="DatasetReader">
    <h3>DatasetReader</h3>
</a>
<p>
    The DatasetReader class is an abstract class, it defines the interface for reading files.
    The only requirement in a dataset reading class is a read method and a filepath attribute, 
    The read method can be concretised by a subclass that is specific for a file type (.gff3)
</p>
<h4>Implementation</h4>
<img class='code' src="{{ url_for('static', filename='code/1.png') }}">
<p>
    To define an abstract class the "ABC" superclass is needed and to define an abstract method the 
    "@abstractmethod" decorator is needed.
</p>
<a id="GFF3DatasetReader">
    <h3>GFF3DatasetReader</h3>
</a>
<p>
    The GFF3DatasetReader class is specific for .gff3 files; it provides an implementation of the abstract 
    read method and it has just one attribute: filepath.
    <br>
    As soon as the reader instance is created and the read method is executed, the program checks if the 
    filepath corresponds to a GFF3 object.
    <br>
    In case the inserted path doesn't lead to a .gff3 file, an exception is raised. Exceptions are raised 
    also in the case that the file is not found or if any other error occurs.
    <br>
    If the filepath is suitable for the reader the pandas.read_csv() function is executed.
</p>
<h4>Implementation</h4>
<img class='code' src="{{ url_for('static', filename='code/2.png') }}">
<p>
    We set several important attributes to ensure a correct and efficient reading of the file:
    <ul>
        <li>sep='\t': the GFF3 files use as separator the tab.</li>
        <li>compression='gzip': the dataset that we are using has a gzip compression, this allows to reduce 
            the file dimensions.
        </li>
        <li>names: we inserted the standard GFF3 header</li>
        <li>comment = '#': accordingly to the project specification, we considered all the lines starting 
            with "#" as comments.
        </li>
        <li>na_values = '.': in GFF3 files, the null values are labeled with a dot.</li>
    </ul>
</p>

<a id="dataset">
    <h2><b>dataset</b></h2>
</a>
<p> 
    We start by importing two libraries:
    <ul>
        <li><b>numbpy</b> as <i>np</i>;</li>
        <li><b>pandas</b> as <i>pd</i>;</li>
    </ul>

    Subsequently from the submodule <b>mock</b> of the module <b>unittest</b> we import the variable <b>patch</b>. Lastly from the module <b>functions</b> we import two functions, <b>get_attribute</b> and <b>activate</b>
</p>
<p>
    Classes:
</p>
<a id="Dataset">
    <h3>Dataset</h3>
</a>
<p>

</p>
<a id="GFF3Dataset">
    <h3>GFF3Dataset</h3>
</a>
<p>

</p>
<p>
    <ul type = "none">
        <li><b>Dataset</b>: a class that provides a view over the data. It is used to distinguish between a generic tabular data and GFF3 data, which is a special case.
            <ul>
                <li><b>Properties:</b></li>
                <ul type = "none">
                    <li> - <b>df</b>: the data representation in the form of a Pandas dataframe;</li>
                    <li> - <b>active_operations</b>: a dictionary of <b>active</b> operations;</li>
                    <li> - <b>operations</b>: a dictionary of <b>avaible</b> operations;</li>
                </ul>
        
                <li><b>Methods:</b></li>
                <ul type = "none">
                    <li> - <b>create</b>: it returns a new instance of <i>GFF3Dataset</i> if the data frame's columns match the format ('Seqid','Source','Type','Start','End','Score','Strand','Phase','Attribute'), otherwise returns self;</li>
                    <li> - <b>get_df</b>: it returns the internal data frame;</li>
                    <li> - <b>get_active_operations</b>: it returns  alla active operations. It is used to show the user the operation that they can use;</li>
                </ul>
            </ul>
        </li>
        <li><br></li>
        <li><b>GFF3DatasetReader</b>: is a subclass of <i>Dataset</i>. It provides several operations that can be performed on GFF3 data.
            <ul>
                <li><b>Properties:</b></li>
                <ul type = "none">
                    <li> - <b>df</b>: the data representation in the form of a Pandas dataframe;</li>
                    <li> - <b>active_operations</b>: a dictionary of <b>active</b> operations;</li>
                    <li> - <b>operations</b>: a dictionary of <b>avaible</b> operations;</li>
                </ul>
        
                <li><b>Methods:</b></li>
                <ul type = "none">
                    <li> - <a id="information"></a><b>information</b>: it returns basic information about the dataset: name and data type of each column;</li>
                    <li> - <a id="unique_sequence_IDs"></a><b>unique_sequence_IDs</b>: it returns a list of unique sequence IDs available in the dataset;</li>
                    <li> - <a id="unique_types"></a><b>unique_types</b>: it returns a list of unique types of operations available in the dataset;</li>
                    <li> - <a id="same_source"></a><b>same_source</b>: it counts the number of <b>features</b> provided by the same source; </li>
                    <li> - <a id="entries_for_each_type"></a><b>entries_for_each_type</b>: 
                    <li> - <a id="chromosomes"></a><b>chromosomes</b>: it derives a new dataset containing only the information about entire chromosomes. Entries with entirechromosomes comes from source <b>GRCh38**</b>; </li>
                    <li> - <a id="fraction_of_unassembled_sequences"></a><b>fraction_of_unassembled_sequences</b>: it returns the fraction of unassembled sequences in the dataset;</li>
                    <li> - <a id="ensembl_havana"></a><b>ensembl_havana</b>: it returns a new dataset containing only entries from source <b>ensembl</b>, <b>havana</b> and <b>esembl_havana</b>;</li>
                    <li> - <a id="entries_for_each_type_ensemblhavana"></a><b>entries_for_each_type_ensemblhavana</b>: it counts the number of entries for each type of operation for the dataset containing only entries from source <b>ensembl</b>, <b>havana</b> and <b>esembl_havana</b>;</li>
                    <li> - <a id="gene_names"></a><b>gene_names</b>: it returns the gene names from the dataset containing containing only entries from source <b>ensembl</b>, <b>havana</b> and <b>esembl_havana</b>;</li>
                </ul>
            </ul>
        </li>
    </ul>
</p>
<a id="functions">
    <h2><b>functions</b></h2>
</a>
<p>
    this module is useful to keep the dataset module cleaner <br>
    it has two functions:
    <ul>
        <li>
            activate: this is the decorator!
        </li>
        <li>
            get_attributes:
        </li>
    </ul>
</p>
<a id="main">
    <h2><b>main</b></h2>
</a>
<p>
    this module is the one that runs the web app, by putting together all the other modules.
    it uses the GFF3 reader to read the dataset of interest, and then it will automatically
    create the dataset instances. the main will be able to deal with all the methods of dataset
    since the dataset_reader module already imports the dataset class
</p>

{% endblock %}