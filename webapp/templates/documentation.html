{%extends "base.html" %}
{%block content%}

<h1>
    <img src="{{ url_for('static', filename='documentation_button.png') }}" height="100px">
    Project documentation
</h1>

<p>
    this is the documentation
</p>


<h2> Software analysis </h2>

<p>
    the sfotware analysis is based on the 
    <a href='https://github.com/kcajj/human_genome_webapp/blob/GFF3-subclass/MarkdownFiles/Project_specification.md' target="_blank">
    project specification</a>.
    <br>
    We built some CRC cards that give an idea of the role of each class.
</p>
<p>
    We identified 4 classes to build:
</p>

<a id="DatasetReader">
    <h4> DatasetReader </h4>
</a>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>DatasetReader
        </th>
        <th>
            <b>Supeclass:</b><br>None
        </th>
        <th>
            <b>Subclasses:</b><br>GFF3DatasetReader
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>Provide an abstract interface for the subclass</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>None</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    The DatasetReader class should be an abstract class, it should provide the abstract methods that 
    will be implemented in the subclass.
</p>

<a id="GFF3DatasetReader">
    <h4> GFF3DatasetReader </h4>
</a>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>GFF3DatasetReader
        </th>
        <th>
            <b>Supeclass:</b><br>DatasetReader
        </th>
        <th>
            <b>Subclasses:</b><br>None
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>Reads specifically a GFF3 file</li>
                <li>Return a dataset object</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>Dataset</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    The GFF3DatasetReader class should be specific for GFF3 files, it should check if the input file is a 
    .gff3 file and then read it correctly, returning a pandas Dataframe inside a Dataset object.
</p>

<a id="Dataset">
    <h4> Dataset </h4>
</a>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>Dataset
        </th>
        <th>
            <b>Supeclass:</b><br>None
        </th>
        <th>
            <b>Subclasses:</b><br>GFF3Dataset
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>non-specific class to store data</li>
                <li>create a GFF3 dataset object if <br>the input data is GFF3</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>pandas.DataFrame</li>
                <li>GFF3Dataset</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    The Dataset class should have two main functions:
    <ul>
        <li>It is a class that wraps a generic pandas dataframes 
            and allows the other parts of the software to access it;
        </li>
        <li>
            It checks if the dataframe that it is wrapping is a gff3 dataset and, if so, it 
            wraps it in another class, specific for gff3 files.
        </li>
    </ul>
</p>

<a id="GFF3Dataset">
    <h4> GFF3Dataset </h4>
</a>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>GFF3Dataset
        </th>
        <th>
            <b>Supeclass:</b><br>Dataset
        </th>
        <th>
            <b>Subclasses:</b><br>None
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>Be specific for GFF3 datasets</li>
                <li>Perform all of the active operations</li>
                <li>Handle the activation of the operations</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>pandas.DataFrame</li>
                <li>pandas.Series</li>
                <li>Dataset</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    The GFF3Dataset class should be specific for GFF3 files, it just wraps a pandas dataframe and 
    provides several operations that retrieve some characteristics of the dataframe or that 
    filter the dataframe on the basis of a condition.
</p>
<p>
    The operations are:
    <ul>
        <li>General information</li>
        <li>Unique sequence IDs:</li>
        <li>Unique types of features</li>
        <li>Features with the same source</li>
        <li>Entries for each type of feature</li>
        <li>Data of entire chromosomes</li>
        <li>Fraction of unassembled sequences</li>
        <li>Features with source ensembl, havana, and ensembl_havana</li>
        <li>Entries for each type of feature, on the database with ensembl, havana and ensembl_havana sources</li>
        <li>All gene names</li>
    </ul>
</p>
<p>
    This class should also automatically handle the activation of the operations. The activation
    should be performed through a decorator.<br>
    For each GFF3Dataset object that is created in the program, a customised list of active operations 
    is created; in this way, even on filtered dataset, we will be able to perform some active operation,
    meaningful for the specifc dataset under consideration.
</p>

<h2> Software design </h2>

<p>
    broad view of the software, with interaction between classes.<br>
    click on the class to explore the detailed documentation.
</p>

<div class="UML">
    <img src="{{ url_for('static', filename='UML_image_new.png') }}" width="100%">
    <a href="#DatasetReader"><button class="DatasetReader"></button></a>
    <a href="#GFF3DatasetReader"><button class="GFF3DatasetReader"></button></a>
    <a href="#Dataset"><button class="Dataset"></button></a>
    <a href="#GFF3Dataset"><button class="GFF3Dataset"></button></a>
    <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html" target="_blank"><button class="pandas_DataFrame"></button></a>
    <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html" target="_blank"><button class="pandas_Series"></button></a>
</div>

<p>
    the software is organised into 4 modules
</p>

<h2> dataset_reader </h2>
<p> 
    We start by importing from the module <b>abc</b> the class <b>ABC</b> and the method <b>abstractmethod</b>.
    Subsequently we import two libraries:
    <ul>
        <li><b>numbpy</b> as <i>np</i>;</li>
        <li><b>pandas</b> as <i>pd</i>;</li>
    </ul>

    Lastly we import the class <b>DataSet</b> from the module <b>dataset</b>.
</p>
<p>
    We also find a total of two classes:
    <ul type = "none">
        <li><b>DatasetReader</b>: is an abstract class that defines the interface for reading dataset files.</li>
            <ul>
                <li><b>Methods:</b></li>
                <ul type = "none">
                    <li> - <b>read</b>: is an abstract method that must be implemented by subclasses to define how to read a dataset file. </li>
                </ul>
            </ul>
        <li><b>GFF3DatasetReader</b>: is a subclass of <i>DatasetReader</i> that is specifically designed to read GFF3 files, it should be 
            compliant with a general abstract interface. It returns a dataset object as output that is a wrapper around a Pandas DataFrame.
            <ul>
                <li><b>Methods:</b></li>
                <ul type = "none">
                    <li> - <b>read</b>: it reads a GFF3 file and returns a <i>Dataset*</i> object.
                        The method first checks if the file has the <b>.gff3.gz</b> extension. If it does not, a <i>ValueError</i> is raised with the message <b>"Invalid file type. Expected .gff3.gz file."</b>
                        The method then uses the <i>pd.read_csv</i> function from the Pandas library to read the GFF3 file.</li>
                </ul>
            </ul>
        </li>
    </ul>
</p>

<h2> dataset </h2>
<p> 
    We start by importing two libraries:
    <ul>
        <li><b>numbpy</b> as <i>np</i>;</li>
        <li><b>pandas</b> as <i>pd</i>;</li>
    </ul>

    Subsequently from the submodule <b>mock</b> of the module <b>unittest</b> we import the variable <b>patch</b>. Lastly from the module <b>functions</b> we import two functions, <b>get_attribute</b> and <b>activate</b>
</p>
<p>
    Again we find a total of two classes:
    <ul type = "none">
        <li><b>Dataset</b>: a class that provides a view over the data. It is used to distinguish between a generic tabular data and GFF3 data, which is a special case.
            <ul>
                <li><b>Properties:</b></li>
                <ul type = "none">
                    <li> - <b>df</b>: the data representation in the form of a Pandas dataframe;</li>
                    <li> - <b>active_operations</b>: a dictionary of <b>active</b> operations;</li>
                    <li> - <b>operations</b>: a dictionary of <b>avaible</b> operations;</li>
                </ul>
        
                <li><b>Methods:</b></li>
                <ul type = "none">
                    <li> - <b>create</b>: it returns a new instance of <i>GFF3Dataset</i> if the data frame's columns match the format ('Seqid','Source','Type','Start','End','Score','Strand','Phase','Attribute'), otherwise returns self;</li>
                    <li> - <b>get_df</b>: it returns the internal data frame;</li>
                    <li> - <b>get_active_operations</b>: it returns  alla active operations. It is used to show the user the operation that they can use;</li>
                </ul>
            </ul>
        </li>
        <li><br></li>
        <li><b>GFF3DatasetReader</b>: is a subclass of <i>Dataset</i>. It provides several operations that can be performed on GFF3 data.
            <ul>
                <li><b>Properties:</b></li>
                <ul type = "none">
                    <li> - <b>df</b>: the data representation in the form of a Pandas dataframe;</li>
                    <li> - <b>active_operations</b>: a dictionary of <b>active</b> operations;</li>
                    <li> - <b>operations</b>: a dictionary of <b>avaible</b> operations;</li>
                </ul>
        
                <li><b>Methods:</b></li>
                <ul type = "none">
                    <li> - <a id="information"></a><b>information</b>: it returns basic information about the dataset: name and data type of each column;</li>
                    <li> - <a id="unique_sequence_IDs"></a><b>unique_sequence_IDs</b>: it returns a list of unique sequence IDs available in the dataset;</li>
                    <li> - <a id="unique_types"></a><b>unique_types</b>: it returns a list of unique types of operations available in the dataset;</li>
                    <li> - <a id="same_source"></a><b>same_source</b>: it counts the number of <b>features</b> provided by the same source; </li>
                    <li> - <a id="entries_for_each_type"></a><b>entries_for_each_type</b>: 
                    <li> - <a id="chromosomes"></a><b>chromosomes</b>: it derives a new dataset containing only the information about entire chromosomes. Entries with entirechromosomes comes from source <b>GRCh38**</b>; </li>
                    <li> - <a id="fraction_of_unassembled_sequences"></a><b>fraction_of_unassembled_sequences</b>: it returns the fraction of unassembled sequences in the dataset;</li>
                    <li> - <a id="ensembl_havana"></a><b>ensembl_havana</b>: it returns a new dataset containing only entries from source <b>ensembl</b>, <b>havana</b> and <b>esembl_havana</b>;</li>
                    <li> - <a id="entries_for_each_type_ensemblhavana"></a><b>entries_for_each_type_ensemblhavana</b>: it counts the number of entries for each type of operation for the dataset containing only entries from source <b>ensembl</b>, <b>havana</b> and <b>esembl_havana</b>;</li>
                    <li> - <a id="gene_names"></a><b>gene_names</b>: it returns the gene names from the dataset containing containing only entries from source <b>ensembl</b>, <b>havana</b> and <b>esembl_havana</b>;</li>
                </ul>
            </ul>
        </li>
    </ul>
</p>
<h2> functions </h2>
<p>
    this module is useful to keep the dataset module cleaner <br>
    it has two functions:
    <ul>
        <li>
            activate: this is the decorator!
        </li>
        <li>
            get_attributes:
        </li>
    </ul>
</p>
<h2> main </h2>
<p>
    this module is the one that runs the web app, by putting together all the other modules.
    it uses the GFF3 reader to read the dataset of interest, and then it will automatically
    create the dataset instances. the main will be able to deal with all the methods of dataset
    since the dataset_reader module already imports the dataset class
</p>

{% endblock %}