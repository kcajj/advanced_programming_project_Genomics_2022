{%extends "base.html" %}
{%block content%}

<h1>
    <img src="{{ url_for('static', filename='documentation_button.png') }}" height="100px">
    Project documentation
</h1>

<p>
    In this page we will go thorugh 
    <a href="#software_analysis">software analysis</a>
    and 
    <a href="#software_design">software design</a>.
</p>

<a id="software_analysis">
    <h2> Software analysis </h2>
</a>

<p>
    the sfotware analysis is based on the 
    <a href='https://github.com/kcajj/human_genome_webapp/blob/GFF3-subclass/MarkdownFiles/Project_specification.md' target="_blank">
    project specification</a>.
    <br>
    We built some CRC cards that give an idea of the role of each class.
</p>
<p>
    We identified 4 classes to build:
</p>

<h4> DatasetReader </h4>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>DatasetReader
        </th>
        <th>
            <b>Supeclass:</b><br>None
        </th>
        <th>
            <b>Subclasses:</b><br>GFF3DatasetReader
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>Provide an abstract interface for <br>the subclass</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>None</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    <br>
    The DatasetReader class should be an abstract class, it should provide the abstract methods that 
    will be implemented in the subclass.
</p>

<h4> GFF3DatasetReader </h4>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>GFF3DatasetReader
        </th>
        <th>
            <b>Supeclass:</b><br>DatasetReader
        </th>
        <th>
            <b>Subclasses:</b><br>None
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>Reads specifically a GFF3 file</li>
                <li>Return a dataset object</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>Dataset</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    <br>
    The GFF3DatasetReader class should be specific for GFF3 files, it should check if the input file is a 
    .gff3 file and then read it correctly, returning a pandas Dataframe inside a Dataset object.
</p>

<h4> Dataset </h4>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>Dataset
        </th>
        <th>
            <b>Supeclass:</b><br>None
        </th>
        <th>
            <b>Subclasses:</b><br>GFF3Dataset
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>non-specific class to store data</li>
                <li>create a GFF3 dataset object if <br>the input data is GFF3</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>pandas.DataFrame</li>
                <li>GFF3Dataset</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    <br>
    The Dataset class should have two main functions:
    <ul>
        <li>It is a class that wraps a generic pandas dataframes 
            and allows the other parts of the software to access it;
        </li>
        <li>
            It checks if the dataframe that it is wrapping is a gff3 dataset and, if so, it 
            wraps it in another class, specific for gff3 files.
        </li>
    </ul>
</p>

<h4> GFF3Dataset </h4>

<table class="crc">
    <tr >
        <th>
            <b>Class name:</b><br>GFF3Dataset
        </th>
        <th>
            <b>Supeclass:</b><br>Dataset
        </th>
        <th>
            <b>Subclasses:</b><br>None
        </th>
    </tr>
    <tr>
        <td colspan="2">
            <b>Responsibilities</b>
            <ul>
                <li>Be specific for GFF3 datasets</li>
                <li>Perform all of the active operations</li>
                <li>Handle the activation of the operations</li>
            </ul>
        </td>
        <td>
            <b>Collaborations</b>
            <ul>
                <li>pandas.DataFrame</li>
                <li>pandas.Series</li>
                <li>Dataset</li>
            </ul>
        </td>
    </tr>
</table>

<p>
    <br>
    The GFF3Dataset class should be specific for GFF3 files, it just wraps a pandas dataframe and 
    provides several operations that retrieve some characteristics of the dataframe or that 
    filter the dataframe on the basis of a condition.
</p>
<p>
    The operations are:
    <ul>
        <li>General information</li>
        <li>Unique sequence IDs:</li>
        <li>Unique types of features</li>
        <li>Features with the same source</li>
        <li>Entries for each type of feature</li>
        <li>Data of entire chromosomes</li>
        <li>Fraction of unassembled sequences</li>
        <li>Features with source ensembl, havana, and ensembl_havana</li>
        <li>Entries for each type of feature, on the database with ensembl, havana and ensembl_havana sources</li>
        <li>All gene names</li>
    </ul>
</p>
<p>
    This class should also automatically handle the activation of the operations. The activation
    should be performed through a decorator.<br>
    For each GFF3Dataset object that is created in the program, a customised list of active operations 
    is created; in this way, even on filtered dataset, we will be able to perform some active operation,
    meaningful for the specifc dataset under consideration.
</p>

<a id="software_design">
    <h2> Software design </h2>
</a>

<p>
    Now we will present a detailed view over the software. This UML diagram shows all of the components of 
    each class and the interactions between the classes.<br>
    Click on a class to explore the detailed documentation.
</p>

<div class="UML">
    <img src="{{ url_for('static', filename='UML_image.png') }}" width="100%">
    <a href="#DatasetReader"><button class="DatasetReader"></button></a>
    <a href="#GFF3DatasetReader"><button class="GFF3DatasetReader"></button></a>
    <a href="#Dataset"><button class="Dataset"></button></a>
    <a href="#GFF3Dataset"><button class="GFF3Dataset"></button></a>
    <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html" target="_blank"><button class="pandas_DataFrame"></button></a>
    <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html" target="_blank"><button class="pandas_Series"></button></a>
</div>

<p>
    explanation of the uml diagram
</p>
<p>
    The software is organised into 4 python modules:
    <a href="#dataset_reader">dataset_reader</a>, 
    <a href="#dataset">dataset</a>, 
    <a href="#functions">functions</a>, 
    <a href="#main">main</a>.
</p>

<a id="dataset_reader">
    <h2><b>dataset_reader</b></h2>
</a>
<p>
    The dataset_reader module performs the decodification of the GFF3 file, it contains a specific class that is able 
    to read a .gff3 file and that returns a Dataset object.
</p>
<p>
    The module requires:
    <ul>
        <li>abc library: it is used to define the Dataset reader class, which is an abstract class</li>
        <li>pandas library: the reading operation is performed thorugh pandas.read_csv(), 
            the resulting pandas DataFrame is wrapped in a Dataset object
        </li>
        <li>Dataset module</li>
    </ul>
</p>
<p>
    this module contains two classes:
</p>
<a id="DatasetReader">
    <h3>DatasetReader</h3>
</a>
<p>
    The DatasetReader class is an abstract class, it defines the interface for reading files.
    The only requirement in a dataset reading class is a read method and a filepath attribute, 
    The read method can be concretised by a subclass that is specific for a file type (.gff3)
</p>
<h4>Implementation</h4>
<img class='code' src="{{ url_for('static', filename='code/1.png') }}">
<p>
    To define an abstract class the "ABC" superclass is needed and to define an abstract method the 
    "@abstractmethod" decorator is needed.
</p>
<a id="GFF3DatasetReader">
    <h3>GFF3DatasetReader</h3>
</a>
<p>
    The GFF3DatasetReader class is specific for .gff3 files; it provides an implementation of the abstract 
    read method and it has just one attribute: filepath.
    <br>
    As soon as the reader instance is created and the read method is executed, the program checks if the 
    filepath corresponds to a GFF3 object.
    <br>
    In case the inserted path doesn't lead to a .gff3 file, an exception is raised. Exceptions are raised 
    also in the case that the file is not found or if any other error occurs.
    <br>
    If the filepath is suitable for the reader the pandas.read_csv() function is executed.
</p>
<h4>Implementation</h4>
<img class='code' src="{{ url_for('static', filename='code/2.png') }}">
<p>
    We set several important attributes to ensure a correct and efficient reading of the file:
    <ul>
        <li>sep='\t': the GFF3 files use as separator the tab.</li>
        <li>compression='gzip': the dataset that we are using has a gzip compression, this allows to reduce 
            the file dimensions.
        </li>
        <li>names: we inserted the standard GFF3 header</li>
        <li>comment = '#': accordingly to the project specification, we considered all the lines starting 
            with "#" as comments.
        </li>
        <li>na_values = '.': in GFF3 files, the null values are labeled with a dot.</li>
    </ul>
</p>

<a id="dataset">
    <h2><b>dataset</b></h2>
</a>
<p> 
    The dataset module performs the majority of the logic operations of the software, it stores and 
    handles all the input data.
    <br>
    This module requires the pandas library, because all of the data is stored in pandas dataframes, 
    and it interacts with the "functions" module. The "functions" module provides the decorator function and 
    another useful function to dataset.py, it is a module used to keep the dataset class more clean.
    <br>
    The patch function (from the built-in "unittest" python module) is imported in this module, it will be 
    used in the "get_active_operations()" method.
</p>
<p>
    this module contains two classes:
</p>
<a id="Dataset">
    <h3>Dataset</h3>
</a>
<p>
    <ul type = "none">
        <li><b>Dataset</b>: a class that provides a view over the data. It is used to distinguish between a generic tabular data and GFF3 data, which is a special case.
            <ul>
                <li><b>Properties:</b></li>
                <ul type = "none">
                    <li> - <b>df</b>: the data representation in the form of a Pandas dataframe;</li>
                    <li> - <b>active_operations</b>: a dictionary of <b>active</b> operations;</li>
                    <li> - <b>operations</b>: a dictionary of <b>avaible</b> operations;</li>
                </ul>
        
                <li><b>Methods:</b></li>
                <ul type = "none">
                    <li> - <b>create</b>: it returns a new instance of <i>GFF3Dataset</i> if the data frame's columns match the format ('Seqid','Source','Type','Start','End','Score','Strand','Phase','Attribute'), otherwise returns self;</li>
                    <li> - <b>get_df</b>: it returns the internal data frame;</li>
                    <li> - <b>get_active_operations</b>: it returns  alla active operations. It is used to show the user the operation that they can use;</li>
                </ul>
            </ul>
        </li>
    </ul>
</p>
<h4>Implementation</h4>
<img class='code' src="{{ url_for('static', filename='code/1.png') }}">
<p>
    To define an abstract class the "ABC" superclass is needed and to define an abstract method the 
    "@abstractmethod" decorator is needed.
</p>
<a id="GFF3Dataset">
    <h3>GFF3Dataset</h3>
</a>
<p>
    <ul>
        <li><b>GFF3DatasetReader</b>: is a subclass of <i>Dataset</i>. It provides several operations that can be performed on GFF3 data.
            <ul>
                <li><b>Properties:</b></li>
                <ul type = "none">
                    <li> - <b>df</b>: the data representation in the form of a Pandas dataframe;</li>
                    <li> - <b>active_operations</b>: a dictionary of <b>active</b> operations;</li>
                    <li> - <b>operations</b>: a dictionary of <b>avaible</b> operations;</li>
                </ul>
        
                <li><b>Methods:</b></li>
                <ul type = "none">
                    <li> - <a id="information"></a><b>information</b>: it returns basic information about the dataset: name and data type of each column;</li>
                    <li> - <a id="unique_sequence_IDs"></a><b>unique_sequence_IDs</b>: it returns a list of unique sequence IDs available in the dataset;</li>
                    <li> - <a id="unique_types"></a><b>unique_types</b>: it returns a list of unique types of operations available in the dataset;</li>
                    <li> - <a id="same_source"></a><b>same_source</b>: it counts the number of <b>features</b> provided by the same source; </li>
                    <li> - <a id="entries_for_each_type"></a><b>entries_for_each_type</b>: 
                    <li> - <a id="chromosomes"></a><b>chromosomes</b>: it derives a new dataset containing only the information about entire chromosomes. Entries with entirechromosomes comes from source <b>GRCh38**</b>; </li>
                    <li> - <a id="fraction_of_unassembled_sequences"></a><b>fraction_of_unassembled_sequences</b>: it returns the fraction of unassembled sequences in the dataset;</li>
                    <li> - <a id="ensembl_havana"></a><b>ensembl_havana</b>: it returns a new dataset containing only entries from source <b>ensembl</b>, <b>havana</b> and <b>esembl_havana</b>;</li>
                    <li> - <a id="entries_for_each_type_ensemblhavana"></a><b>entries_for_each_type_ensemblhavana</b>: it counts the number of entries for each type of operation for the dataset containing only entries from source <b>ensembl</b>, <b>havana</b> and <b>esembl_havana</b>;</li>
                    <li> - <a id="gene_names"></a><b>gene_names</b>: it returns the gene names from the dataset containing containing only entries from source <b>ensembl</b>, <b>havana</b> and <b>esembl_havana</b>;</li>
                </ul>
            </ul>
        </li>
    </ul>
</p>
<a id="functions">
    <h2><b>functions</b></h2>
</a>
<p>
    this module is useful to keep the dataset module cleaner. <br>
    It has two functions:
</p>
<a id="decorator">
    <h3>activate</h3>
</a>
<p>
    The activate function is the decorator responsible for the activation of the operations in the 
    GFF3Dataset class. The decorator is a core component of our software, it is the function that 
    allows to activate a different set of functions for each GFF3Dataset object, in this way, the same 
    operations (given that they are activated) can be executed on different datasets (namely, the 
    starting dataset and the filtered ones).
</p>
<p>
    This function decorates all of the operations and, each time an operation is executed, it examins the 
    output and decides whether the operation should be activated or not.
    <br>
    The behaviours that trigger the inactivation of an operation are two:
    <ul>
        <li>the operation produces an error during execution</li>
        <li>the operation produces an empty Dataset as output</li>
    </ul>
</p>
<p>
    Once an operation has been activated, for all the subsequent executions, its output will not be checked, 
    in this way, some computational memory is saved.
</p>
<h4>Implementation</h4>
<img class='code' src="{{ url_for('static', filename='code/6.png') }}">

<h3>get_attributes</h3>
<p>
    This function simply takes in input a row of the "attribute" column of a GFF3 file and returns as 
    output a dictionary, in which the keys are the names of all the attributes of the row and the 
    values are the values of those attributes.<br>
    <i>
        Example:<br>
        Attribute line: "ID=gene:ENSG00000223972;Name=DDX11L1;"<br>
        Output object: "{'ID':'gene:ENSG00000223972','Name':'DDX11L1'}"<br>
    </i>
    The get_attribute function is used by the 
    <a href="#gene_names">gene_names</a> operation
</p>

<a id="main">
    <h2><b>main</b></h2>
</a>
<p>
    The main module is responsible for putting together the webapp, it uses the tools defined in 
    the other modules and in provides the structure of the flask app.
</p>
<h4>Preliminary operations</h4>
<p>
    <br>
    The preliminary instructions of this module consist in the loading of the starting dataset (Homo_sapiens.GRCh38.85.gff3.gz), 
    by creating a GFF3DatasetReader instance and by running the read() method. The Dataset instance resulting 
    from the read is stored in the "human_genome".
    <br>
    <img src="{{ url_for('static', filename='code/3.png') }}" width="30%">
</p>
<p>
    Subsequently some useful variables are initiated: The app is provided with two global variables 
    that will be read and modified by all over the program. The "global_active_op" variable stores 
    the active operations for the dataset that is under analysis in the program, while "current_dataset_name" 
    stores the name of the dataset under analysis in the program. Since the starting dataset is the human genome, 
    all of the operations will be active and the dataset name will be "human_genome".
    <br>
    <img src="{{ url_for('static', filename='code/4.png') }}" width="30%">
</p>
<p>
    Another important preliminary component fo the main.py module is the datasets dictionary. This dictionary 
    exploits the "get_subdatasets()" method of the Dataset object to get all the results of the filter operations, 
    then it stores these results in a dictionary together with the full dataset.
    <br>
    This dictionary will allow us to change the active dataset from allover the program.
    <br>
    <img src="{{ url_for('static', filename='code/5.png') }}" width="30%">
</p>
<h4>Flask application</h4>
<p>
    In order to run a flask webapp all the routes of the site have to be defined in the python file. 
    Our application has 5 routes, each is characterised by the "@app.route" decorator, and each route 
    (except "download") shows a different HTML file. The function that links a route to an HTML file 
    is "render_template()".
    <br>
</p>
<p>
    The routes are:
    <ul>
        <li>
            <b>homepage</b>: loads the "homepage.html" template, this page explain the purposes of the we application 
            and describes the role of the other pages
        </li>
        <li>
            <b>operations</b>: this page shows the list of active operations, it takes the dataset name as input, 
            in this way, if the active dataset is changed, the active operations are changed accordingly and the 
            current_active_dataset varible is updated.
        </li>
        <li>
            <b>operation_result</b>: this page is responsible of showing the result of the execution of an operation.
            <br>
            It can be accessed from two buttons: from an "execute operation" button and from the "open in another 
            tab" button.
            <br>
            This function has 3 possible outputs:
            <ul>
                <li>If it was called from a normal operation, the page will show the table containing the result 
                    of the execution.
                </li>
                <li>If it was called from a filter operation, the "operations" view will be re-proposed, with a 
                    restricted dataset to work on.
                </li>
                <li>If it was called from the "open in another tab" button, the page will show a whole GFF3 dataset</li>
            </ul>
        </li>
        <li>
            <b>documentation</b>: loads the "documentation.html" template, the one you're reading right now
        </li>
        <li>
            <b>download</b>: gives the possibility to download a .csv file, created from a pandas dataframe, in the 
            computer of the user.
        </li>
    </ul>
</p>

{% endblock %}